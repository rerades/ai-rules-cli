---
id: testing.unit-testing.vitest
version: 1.0.0
title: "Unit Testing with Vitest"
summary: "Comprehensive guidelines for creating unit tests using Vitest and TypeScript, focusing on critical functionality, dependency mocking, and maintainable test patterns."
category: testing
scope: ["global", "repo", "package", "workspace", "app", "component"]
language: "javascript"
frameworks: ["vitest", "typescript"]
tooling: ["vitest", "typescript", "vi"]
lifecycle: "enforced"
maturity: "stable"
stability: "locked"
audience: ["frontend", "backend", "fullstack", "qa"]
severity: "high"
requires: []
conflicts: []
supersedes: []
bundles: ["testing/unit-testing", "testing/vitest"]
files: ["**/*.test.js", "**/*.test.ts", "**/*.spec.js", "**/*.spec.ts"]
enforcement: { lint: "error", ci: "require", scaffold: "suggest" }
order: 20
inputs:
  autoDetectTypeScript:
    {
      type: "boolean",
      default: true,
      description: "Auto-detect TypeScript usage through tsconfig.json or package.json dependencies",
    }
  maxTestsPerFile:
    {
      type: "number",
      default: 5,
      description: "Maximum number of focused tests per file for maintainability",
    }
  requireMocking:
    {
      type: "boolean",
      default: true,
      description: "Require mocking of dependencies before imports",
    }
  testCriticalFunctionality:
    {
      type: "boolean",
      default: true,
      description: "Prioritize testing business logic and utility functions",
    }
tags: ["topic:unit-testing", "topic:vitest", "topic:testing", "topic:quality"]
owner: "testing@tu-org.com"
review: { lastReviewed: "2025-01-20", reviewCycleDays: 90 }
license: "MIT"
links:
  - { rel: "docs", href: "https://vitest.dev/", title: "Vitest Documentation" }
  - {
      rel: "docs",
      href: "https://vitest.dev/api/vi.html",
      title: "Vitest Mocking API",
    }
---

# Unit Testing with Vitest

## Persona

You are an expert developer with deep knowledge of Vitest and TypeScript, tasked with creating unit tests for JavaScript/TypeScript applications.

## Auto-detect TypeScript Usage

Check for TypeScript in the project through tsconfig.json or package.json dependencies.
Adjust syntax based on this detection.

## Unit Testing Focus

Create unit tests that focus on critical functionality (business logic, utility functions)
Mock dependencies (API calls, external modules) before imports using vi.mock
Test various data scenarios (valid inputs, invalid inputs, edge cases)
Write maintainable tests with descriptive names grouped in describe blocks

## Best Practices

**1** **Critical Functionality**: Prioritize testing business logic and utility functions
**2** **Dependency Mocking**: Always mock dependencies before imports with vi.mock()
**3** **Data Scenarios**: Test valid inputs, invalid inputs, and edge cases
**4** **Descriptive Naming**: Use clear test names indicating expected behavior
**5** **Test Organization**: Group related tests in describe/context blocks
**6** **Project Patterns**: Match team's testing conventions and patterns
**7** **Edge Cases**: Include tests for undefined values, type mismatches, and unexpected inputs
**8** **Test Quantity**: Limit to 3-5 focused tests per file for maintainability

## Example Unit Test

```js
import { describe, it, expect, beforeEach } from "vitest";
import { vi } from "vitest";

// Mock dependencies before imports
vi.mock("../api/locale", () => ({
  getLocale: vi.fn(() => "en-US"), // Mock locale API
}));

// Import module under test
const { formatDate } = await import("../utils/formatDate");

describe("formatDate", () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  it("should format date correctly", () => {
    // Arrange
    const date = new Date("2023-10-15");

    // Act
    const result = formatDate(date);

    // Assert
    expect(result).toBe("2023-10-15");
  });

  it("should handle invalid date", () => {
    const result = formatDate(new Date("invalid"));
    expect(result).toBe("Invalid Date");
  });

  it("should throw error for undefined input", () => {
    expect(() => formatDate(undefined)).toThrow("Input must be a Date object");
  });

  it("should handle non-Date object", () => {
    expect(() => formatDate("2023-10-15")).toThrow(
      "Input must be a Date object"
    );
  });
});
```

## TypeScript Example

```ts
import { describe, it, expect, beforeEach } from "vitest";
import { vi } from "vitest";

// Mock dependencies before imports
vi.mock("../api/weatherService", () => ({
  getWeatherData: vi.fn(),
}));

// Import the mocked module and the function to test
import { getWeatherData } from "../api/weatherService";
import { getForecast } from "../utils/forecastUtils";

// Define TypeScript interfaces
interface WeatherData {
  temperature: number;
  humidity: number;
  conditions: string;
}

interface Forecast {
  prediction: string;
  severity: "low" | "medium" | "high";
}

describe("getForecast", () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  it("should return forecast when weather data is available", async () => {
    // Arrange
    const mockWeather: WeatherData = {
      temperature: 25,
      humidity: 65,
      conditions: "sunny",
    };
    (getWeatherData as any).mockResolvedValue(mockWeather);

    // Act
    const result = await getForecast("New York");

    // Assert
    expect(getWeatherData).toHaveBeenCalledWith("New York");
    expect(result).toEqual({
      prediction: "Clear skies",
      severity: "low",
    });
  });

  it("should handle missing data fields", async () => {
    // Arrange: Weather data with missing fields
    const incompleteData = { temperature: 25 };
    (getWeatherData as any).mockResolvedValue(incompleteData);

    // Act & Assert
    await expect(getForecast("London")).rejects.toThrow(
      "Incomplete weather data"
    );
  });

  it("should handle API errors gracefully", async () => {
    // Arrange: API failure
    (getWeatherData as any).mockRejectedValue(new Error("Service unavailable"));

    // Act & Assert
    await expect(getForecast("Tokyo")).rejects.toThrow(
      "Failed to get forecast: Service unavailable"
    );
  });
});
```

## Testing Patterns

### Mocking Strategy

1. **Mock before imports**: Always use `vi.mock()` before importing modules
2. **Clear mocks**: Use `vi.clearAllMocks()` in `beforeEach` hooks
3. **Type-safe mocking**: Use TypeScript interfaces for mock data
4. **Realistic mocks**: Create mocks that reflect real API responses

### Test Structure

```js
describe("Component/Function Name", () => {
  beforeEach(() => {
    // Setup and cleanup
    vi.clearAllMocks();
  });

  describe("specific behavior group", () => {
    it("should handle valid input", () => {
      // Arrange, Act, Assert
    });

    it("should handle invalid input", () => {
      // Test error cases
    });

    it("should handle edge cases", () => {
      // Test boundary conditions
    });
  });
});
```

### Assertion Patterns

- Use specific matchers: `toBe()`, `toEqual()`, `toContain()`
- Test async operations with `async/await` and `rejects.toThrow()`
- Verify mock calls with `toHaveBeenCalledWith()`
- Test error conditions with `toThrow()`

## Configuration

### Vitest Configuration

```js
// vitest.config.js
export default {
  test: {
    globals: true,
    environment: "node",
    setupFiles: ["./test/setup.js"],
  },
};
```

### TypeScript Support

```json
// tsconfig.json
{
  "compilerOptions": {
    "types": ["vitest/globals"]
  }
}
```

## Quality Gates

- **Coverage**: Aim for 80%+ coverage on critical business logic
- **Performance**: Tests should run in under 5 seconds per file
- **Maintainability**: Maximum 5 tests per file, clear naming
- **Reliability**: No flaky tests, deterministic outcomes

## Anti-patterns to Avoid

- ❌ Testing implementation details instead of behavior
- ❌ Not mocking external dependencies
- ❌ Overly complex test setups
- ❌ Testing multiple concerns in one test
- ❌ Using `any` type in TypeScript tests
- ❌ Not cleaning up mocks between tests

## Integration with CI/CD

```yaml
# .github/workflows/test.yml
- name: Run tests
  run: |
    npm run test:unit
    npm run test:coverage
```

## Tools and Extensions

- **VS Code**: Vitest extension for test running
- **Debugging**: Use `--inspect-brk` for debugging tests
- **Coverage**: Use `--coverage` flag for coverage reports
- **Watch mode**: Use `--watch` for development workflow
